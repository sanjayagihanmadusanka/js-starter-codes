
high level: we don't have to worry about lot of stuffs, like memory handlig, provides build in methods
multi paradigm: imperative and declative programming

ES - ecma script
ES6 - 2015

var → initialized to undefined.
let → initialized to undefined but in TDZ until declaration.
const → must be initialized immediately.
Undeclared variable → ReferenceError.
Missing object property / array element → undefined

camelCase = firstName
PascalCase = firstName
snake_case = first_name

we can start variable names with _ and $

Primitive Types:
string: "Alice", number: 25 or 25.11, bigint: large ints, boolean: true/false, undefined: (let x;), null: (let x = null)

Non-Primitive
object: let user = { name: "Alice", age: 25 };
array: let numbers = [1, 2, 3];
function

typeof null;       // "object"

var: function scoped else global, can be re declared even in the same scoped
let: Block-scoped, cannot redeclare
const: Block-scoped, no redeclaration and reassignment

x = y = z; // valid

let name = "sanjaya"
template literal: console.log(`my name is ${name}`)

when we use "use strict"; we have to declare variables before using them(thows an error), if not declaration is not compulsory.
when we assign a value to a variable without declaring it,

type conversion (Type Casting): Explicit conversion
// String to Number
let str = "123";
let num = Number(str);   // explicit conversion
console.log(num);        // 123 (number)
// Number to String
let n = 42;
let s = String(n);       // explicit conversion
console.log(s);          // "42" (string)
// Boolean to Number
let b = true;
console.log(Number(b));  // 1

Type Coercion: Implicit conversion (done automatically by JavaScript).
// String + Number → String (concatenation)
console.log("5" + 2);  // "52"
// String - Number → Number (subtraction forces numeric conversion)
console.log("5" - 2);  // 3
// Boolean → Number (in arithmetic)
console.log(true + 1); // 2

